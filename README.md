# Flask

Flask — микрофреймворк Python. Армин Ронахерсозданный создал его в 2010

## Установка в виртуальное окружение

```bash
python3 -m venv .venv
cd .venv
.venv/bin/activate
pip install Flask
```

### Устанавливаемые зависимости

- Werkzeug - сервер WSGI, отвечает за обработку HTTP-запросов и ответов, роутинг, дебагер и релоудер
- Jinja2 - шаблонизатор
- click - консольная команда flask
- itsdangerous - утилита для защиты от уязвимостей
- markupsafe - утилита для защиты от уязвимостей

### Веб-приложение

[Hello world](lesson_1/app_01.py)

Создаем экземпляр класса `Flask` по имени `app`, которому передаем имя текущего модуля

```python
app = Flask(__name__)
```

Декоратор `app.route` позволяет определить маршрут, при вводе которого будет выполняться функция `hello_world`

```python
@app.route('/')
def hello_world():
    return 'Hello, World!'
```

Функция может возвращать в том числе и строковые значения.

Функция app.run() отвечает за запуск веб-сервера с переданными ей параметрами

```python
app.run(host='0.0.0.0', port=5500)
```

## Запуск веб-приложения

Запустить приложение flask можно несколькими способами

1. Через IDE: с помощью кнопки "Run" в верхнем правом углу VSC
2. Классическим способом: `python3 module_name.py` 
3. С помощью пакета click: `flask --app module_name.py run` 
4. С помощью скрипта wsgi.py: `flask run`

### wsgi.py

При выполнении команды `flask run` ищется файл `wsgi.py` в текущей директории и в случае его наличия запускается веб-сервер.

wsgi.py файл содержит строку, которая импортирует приложение из нужной директории и условие запуска веб-сервера с необходимыми параметрами:

```python
from package.module_name import app

if __name__ == "__main__":
    app.run(debug=True)
```

## View функция

Или функция-представление

Декоратор `@app.route()` используется для привязки роутинга `hello` к функции-представлению `hello()`:

```python
@app.route('/hello/')
def hello():
    return 'Hello, World!'
```

При отрытии в браузере http://127.0.0.1:5500/hello/ выводится строка `Hello, World!`

**Важно** не забывать ставить слеш в конце роутинга, который передаётся в route().

Одна функция-представление может быть привязана к нескольким декораторам:

```python
@app.route('/Фёдор/')
@app.route('/Fedor/')
@app.route('/Федя/')
def fedor():
    return 'Привет, Феодор!'
```

## Переменные

Через роутинг можно передать переменную в функцию-представление:

```python
@app.route('/<name>/')
def hello(name):
    return f'Hello, {name}!'
```

где `<name>` переменная передаваемая через строку браузера, т.е. является частью адреса url, в функции-представлении переменная используется без треугольных кавычек.

### Типы переменных

- [string](lesson_1/app_02.py) (по умолчанию), строка без слешей
- int целые положительные числа
- [float](lesson_1/app_03.py) вещественные числа
- [path](lesson_1/app_04.py) путь к файлу, т.е. строка включая слэши
- uuid уникальный идентификатор

При передаче другого типа данных вызовет ошибку 404

## Вывод HTML

### Многострочный текст

[Используя тройные кавычки](lesson_1/app_05.py)

### Рендеринг HTML файла

Чтобы отрисовать файл [index.html](lesson_1/templates/index.html) в браузере:

1. html-файл нужно поместить в папку `templates`, расположенной на одном уровне с запускаемым веб-приложением.
2. в приложении пайтона нужно подключить функцию отрисовки шаблона из библиотеки Flask:

```python
from flask import render_template
```

3. в функции-представлении нужно вернуть функцию отрисовки с указанием html-файла в качестве аргумента:

```python
@app.route('/index/')
def html_index():
    return render_template('index.html')
```

[Полный код рендеринга файла html](lesson_1/app_06.py)

## Шаблонизатор Jinja

Отрисовкой html файлов занимается библиотека Jinja, она превращает статические html-страницы в шаблоны для формирования переиспользуемого контента


### Проброс контекста из функции-представления в шаблон

Функция render_template после имени шаблона может принимать неограниченное число именованных аргументов и пробрасывать их в шаблон

```python
return render_template('index.html', name='Харитон')
```

В шаблоне заменим имя владельца на вывод переменной из шаблона внутри двойных фигурных скобок:

```html
<h1 class="text-monospace">Привет, меня зовут {{ name }}</h1>
```

Для компактности переменные объединяют в один словарь, передают его в рендерящую функции и там же его распаковывают:

```python
@app.route('/index/')
def index():
    context = {
        'title': 'Личный блог',
        'name': 'Харитон',
    }
    return render_template('index.html', **context)
```

При написании переменных внутри шаблона рекомендуют имя и скобки отделять пробелом:

```html
<title>{{ title }}</title>
```

### Условный оператор в шаблоне

Если в шаблон передали переменную user, то будет выведен абзац текста, иначе ничего.

```html
{% if user %}
    <p>Вы вошли под именем {{ user }}</p>
{% endif %}
```

Поддерживаются более сложные условия. Например можно добиться правильного окончания в предложении:

```html
<p>К прочтению предлагается {{ number }}
    {% if number == 1 %}
        пост
    {% elif 2 <= number <= 4 %}
        поста
    {% else %}
        постов
    {% endif %}
</p>
```

### Цикл в шаблоне

[Поэма в виде списка предложений](lesson_1/app_09.py)

Используя цикл в шаблоне можно вывести все элементы списка, т.е. всю поэму:

```python
{% for item in item_list %}
    {{ item }}
{% endfor %}
```

[Вывод поэмы в шаблоне html](lesson_1/templates/show_for.html)

### Вывод сложных структур в цикле шаблона

С помощью цикла в шаблоне можно отображать сложные структуры, например [список словарей](lesson_1/app_10.py), используя точечную нотацию для доступа к вложенными элементам структуры:

```html
<body>
    <div class="row">
        <h1 class="col-12 text-monospace text-center">Список пользователей из БД</h1>
        {% for user in users %}
            <div class="col-12 col-md-6 col-lg-4">
                <h2>{{ user.name }}</h2>
                <p>{{ user.mail }}</p>
                <p>{{ user.phone }}</p>
            </div>
        {% endfor %}
    </div>
</body>
```

### Наследование шаблонов

Применяя наследование шаблонов соблюдается принцип DRY (Don't Repeat Yourself)

Например, имеем два html файла:

- [main.html](lesson_1/templates/main.html) - 45 строк кода
- [data.html](lesson_1/templates/data.html) - 28 строк кода

В результате 73 строк рендерется с помощью [скрипта пайтона](lesson_1/app_11.py)

Можно сократить количество информации за счет оптимизации дублирования, для этого создадим базовый  и дочерний шаблоны.


1. Всю одинаковую информацию поместим в [базовый шаблон](lesson_1/templates/base.html) - 30 строк

Уникальную информацию поместим в дочерние шаблоны:

2. [new_main.html](lesson_1/templates/new_main.html) - 10 строк

3. [new_data.html](lesson_1/templates/new_data.html) 27 строк

В итоге 67 строк рендерятся [обновленным скриптом](lesson_1/app_11_update.py). Разница в количестве информации будет заметнее при большем количестве разделов сайта.

Использование переменной {{ super() }} в дочерних шаблонах позволяет выводить содержимое родительского блока, а не заменять его!
Сохранять текстовую информацию в data.html нелогично, ее нужно хранить в БД, тогда шаблон будет получать её через контекст и выводить в цикле.

